{"id": "imo-2024-q1", "question": "Find all real numbers $\\alpha$ so that, for every positive integer $n$, the integer\n\\[ \\left\\lfloor \\alpha \\right\\rfloor + \\left\\lfloor 2 \\alpha \\right\\rfloor\n  + \\left\\lfloor 3 \\alpha \\right\\rfloor + \\dots + \\left\\lfloor n \\alpha \\right\\rfloor \\]\nis divisible by $n$.", "solution": "<div class=\"mdframed\">\nFind all real numbers $\\alpha$ so that, for every positive integer $n$, the integer\n\\[ \\left\\lfloor \\alpha \\right\\rfloor + \\left\\lfloor 2 \\alpha \\right\\rfloor + \\left\\lfloor 3 \\alpha \\right\\rfloor + \\dots + \\left\\lfloor n \\alpha \\right\\rfloor \\]\nis divisible by $n$.\n\\end{div}\nThe answer is that $\\alpha$ must be an even integer.\nLet $S(n, \\alpha)$ denote the sum in question.\n\n\\paragraph{Analysis for $\\alpha$ an integer.}\nIf $\\alpha$ is an integer, then the sum equals\n\\[ S(n, \\alpha) = (1+2+\\dots+n) \\alpha = \\frac{n(n+1)}{2} \\cdot \\alpha \\]\nwhich is obviously a multiple of $n$ if $2 \\mid \\alpha$; meanwhile, if $\\alpha$ is an odd integer then $n = 2$ gives a counterexample.\n\n\\paragraph{Main case.}\nSuppose $\\alpha$ is not an integer; we show the desired condition can never be true.\nNote that replacing $\\alpha$ with $\\alpha \\pm 2$ changes by\n\\[ S(n \\pm 2, \\alpha) - S(n, \\alpha) = 2(1+2+\\dots+n) = n(n+1) \\equiv 0 \\pmod n \\]\nfor every $n$.\nThus, by shifting appropriately we may assume $-1 < \\alpha < 1$ and $\\alpha \\notin \\mathbb{Z}$.\n\n<ul>\n  \\ii If $0 < \\alpha < 1$,\n  then let $m \\ge 2$ be the smallest integer such that $m \\alpha \\ge 1$.\n  Then\n  \\[ S(m, \\alpha) = \\underbrace{0 + \\dots + 0}_{m-1\\text{ terms}} + 1 = 1 \\]\n  is not a multiple of $m$.\n\n  \\ii If $-1 < \\alpha < 0$,\n  then let $m \\ge 2$ be the smallest integer such that $m \\alpha \\le -1$.\n  Then\n  \\[ S(m, \\alpha) = \\underbrace{(-1) + \\dots + (-1)}_{m-1\\text{ terms}} + 0 = -(m-1) \\]\n  is not a multiple of $m$.\n</ul>\n\\pagebreak", "category": null, "source": "IMO", "year": 2024, "content": "Find all real numbers $\\alpha$ so that, for every positive integer $n$, the integer\n\\[\n\\left\\lfloor \\alpha \\right\\rfloor + \\left\\lfloor 2 \\alpha \\right\\rfloor + \\left\\lfloor 3 \\alpha \\right\\rfloor + \\dots + \\left\\lfloor n \\alpha \\right\\rfloor\n\\]\nis divisible by $n$."}
{"id": "imo-2024-q2", "question": "For which pairs of positive integers $(a,b)$ is the sequence\n\\[ \\gcd(a^n+b, b^n+a) \\qquad n = 1, 2, \\dotsc \\]\neventually constant?", "solution": "<div class=\"mdframed\">\nFor which pairs of positive integers $(a,b)$ is the sequence\n\\[ \\gcd(a^n+b, b^n+a) \\qquad n = 1, 2, \\dotsc \\]\neventually constant?\n</div>\nThe answer is $(a,b)=(1,1)$ only, which obviously works since the sequence is always $2$.\n\nConversely, assume the sequence\n\\[ x_n := \\gcd(a^n+b, b^n+a) \\] is eventually constant.\nThe main crux of the other direction is to consider\n\\[ M := ab+1. \\]\n<div class=\"remark*\">\n  [Motivation]\n  The reason to consider the number is the same technique used in IMO 2005/4,\n  namely the idea to consider ``$n = -1$''.\n  The point is that the two rational numbers\n  \\[ \\frac 1a + b = \\frac{ab+1}{b}, \\qquad \\frac 1b + a = \\frac{ab+1}{a} \\]\n  have a large common factor: we could write ``$x_{-1} = ab + 1$'', loosely speaking.\n\n  Now, the sequence is really only defined for $n \\ge 1$,\n  so one should instead take $n \\equiv -1 \\pmod{\\varphi(M)}$\n  --- and this is exactly what we do.\n</div>\nObviously $\\gcd(a,M) = \\gcd(b,M) = 1$.\nLet $n$ be a sufficiently large multiple of $\\varphi(M)$\nso that \\[ x_{n-1} = x_n = x_{n+1} = \\dotsb. \\]\nWe consider the first three terms;\nthe first one is the ``key'' one that gets the bulk of the work,\nand the rest is bookkeeping and extraction.\n<ul>\n  \\ii Consider $x_{n-1}$.\n  Note that\n  \\[ a (a^{n-1} + b) = a^n + ab \\equiv 1 + (-1) \\equiv 0 \\pmod M \\]\n  and similarly $b (b^n + a) \\equiv 0 \\pmod M$.\n  Hence $M \\mid x_{n-1}$.\n\n  \\ii Consider $x_n$, which is now known to be divisible by $M$. Note that\n  \\begin{align*}\n    0 &\\equiv a^n + b \\equiv 1 + b \\pmod M \\\\\n    0 &\\equiv b^n + a \\equiv 1 + a \\pmod M.\n  \\end{align*}\n  So $a \\equiv b \\equiv -1 \\pmod M$.\n\n  \\ii Consider $x_{n+1}$, which is now known to be divisible by $M$. Note that\n  \\[ 0 \\equiv a^{n+1} + b \\equiv b^{n+1} + a \\equiv a + b \\pmod M. \\]\n  We knew $a \\equiv b \\equiv -1 \\pmod M$,\n  hence this means $0 \\equiv 2 \\pmod M$, so $M = 2$.\n</ul>\nFrom $M = 2$ we then conclude $a = b = 1$, as desired.\n\n<div class=\"remark*\">\n  [No alternate solutions known]\n  At the time nobody seems to know any solution not depending critically\n  on $M = ab+1$ (or prime numbers dividing $M$, etc.).\n  They vary in execution once some term of the form $x_{k\\varphi(n)-1}$ is taken,\n  but avoiding the key idea altogether does not currently seem possible.\n\n  A good example to consider for ruling out candidate ideas is $(a,b) = (18,9)$.\n</div>\n\\pagebreak", "category": null, "source": "IMO", "year": 2024, "content": "For which pairs of positive integers $(a,b)$ is the sequence\n\\[\n\\gcd(a^n+b, b^n+a) \\qquad n = 1, 2, \\dotsc\n\\]\neventually constant?"}
{"id": "imo-2024-q3", "question": "Let $a_1$, $a_2$, $a_3$, \\dots\\ be an infinite sequence of positive integers,\nand let $N$ be a positive integer.\nSuppose that, for each $n > N$,\nthe number $a_n$ is equal to the number of times $a_{n-1}$ appears\nin the list $(a_1, a_2, \\dots, a_{n-1})$.\nProve that at least one of the sequences $a_1$, $a_3$, $a_5$, \\dots\\\nand $a_2$, $a_4$, $a_6$, \\dots\\ is eventually periodic.", "solution": "<div class=\"mdframed\">\nLet $a_1$, $a_2$, a_3$, \\dots\\ be an infinite sequence of positive integers,\nand let $N$ be a positive integer.\nSuppose that, for each $n > N$,\nthe number $a_n$ is equal to the number of times $a_{n-1}$ appears\nin the list $(a_1, a_2, \\dots, a_{n-1})$.\nProve that at least one of the sequences $a_1$, $a_3$, a_5, \\dots\\\nand $a_2$, a_4, a_6, \\dots\\ is eventually periodic.\n</div>\nWe present the solution from \"gigamilkmen'tgeg\"\nin \\url{https://aops.com/community/p31224483},\nwith some adaptation from the first shortlist official solution as well.\nSet $M := \\max(a_1, \\dots, a_N)$.\n\n\\paragraph{Setup.}\nWe will visualize the entire process as follows.\nWe draw a stack of towers labeled $1$, $2$, \\dots, each initially empty.\nFor $i=1,2,\\dots$, we imagine the term $a_i$ as adding a block $B_i$ to tower $a_i$.\n\nThen there are $N$ initial blocks placed, colored <em>red</em>.\nThe rest of the blocks are colored <em>yellow</em>:\nif the last block $B_i$ was added to a tower that then reaches height $a_{i+1}$,\nthe next block $B_{i+1}$ is added to tower $a_{i+1}$.\nWe'll say $B_i$ <em>contributes</em> to the tower containing $B_{i+1}$.\n\nIn other words, the yellow blocks $B_i$ for $i > N$\nare given coordinates $B_i = (a_i, a_{i+1})$ for $i>N$.\nNote in particular that in towers $M+1$, $M+2$, \\dots, the blocks are all yellow.\n\n<div class=\"center\">\n<div class=\"asy\">\nunitsize(0.85cm);\nint[] a = {1,2,2,2,2,2,3,4,1,2,6,1,3,2,7,1,4,2,8,1,5,1,6,2,9,1,7,2,10};\nint N = 8;\n\nfilldraw(shift(0,0)*unitsquare, palered, black+1);\nfilldraw(shift(1,0)*unitsquare, palered, black+1);\nfilldraw(shift(2,0)*unitsquare, palered, black+1);\nfilldraw(shift(3,0)*unitsquare, palered, black+1);\nfilldraw(shift(1,1)*unitsquare, palered, black+1);\nfilldraw(shift(1,2)*unitsquare, palered, black+1);\nfilldraw(shift(1,3)*unitsquare, palered, black+1);\nfilldraw(shift(1,4)*unitsquare, palered, black+1);\n\nfor (int i=N; i<a.length-1; ++i) {\n  filldraw(shift(a[i]-1, a[i+1]-1)*unitsquare, paleyellow, black+1);\n}\ndraw((0,0)--(4,0)--(4,1)--(2,1)--(2,5)--(1,5)--(1,1)--(0,1)--cycle, brown+2);\nlabel(\"$\\boxed{N}$\", (a[N-1]-0.5, a[N]-0.5), fontsize(14pt));\n\nvoid draw_arrow(int k, pen p) {\n  draw((a[k-1]-0.5,a[k]-0.5)--(a[k]-0.5,a[k+1]-0.5,\n    p, EndArrow(TeXHead), Margin(2,2));\n}\n\ndraw((0,0)--(4,10)--(4,-0.7), deepgreen);\nlabel(\"$M$\", (4,-0.7), dir(-90), deepgreen);\n\nfor (int j=1; j<=9; ++j) {\n  label(\"$\"+(string)j+\"$\", (j-0.5,0), dir(-90), blue+fontsize(10pt));\n}\n\n// Figure 1: setup\nfor (int i=8; i<=14; ++i) { draw_arrow(i, black+1.0); }\n\nfor (int i=N; i<a.length-1; ++i) {\n  label(\"$\"+(string)(i+1)+\"$\", (a[i]-0.5, a[i+1]-0.5), fontsize(12pt));\n}\n</div>\n</div>\n\nWe let $h_\\ell$ denote the height of the $\\ell^\\text{th}$ tower at a given time $n$.\n(This is an abuse of notation and we should write $h_\\ell(n)$ at time $n$,\nbut $n$ will always be clear from context.)\n\n\\paragraph{Up to alternating up and down.}\nWe start with two independent easy observations:\nthe set of numbers that occur infinitely often is downwards closed,\nand consecutive terms cannot both be huge.\n\n<div class=\"center\">\n<div class=\"asy\">\nunitsize(0.85cm);\nint[] a = {1,2,2,2,2,2,3,4,1,2,6,1,3,2,7,1,4,2,8,1,5,1,6,2,9,1,7,2,10,1,8,2,11,1,9,2,12};\nint N = 8;\n\n// Red X region\nfill(box((4,4),(11,12)), lightgray);\ndraw((4,4)--(11,12), red+1.4);\ndraw((11,4)--(4,12), red+1.4);\n\nfilldraw(shift(0,0)*unitsquare, palered, black+1);\nfilldraw(shift(1,0)*unitsquare, palered, black+1);\nfilldraw(shift(2,0)*unitsquare, palered, black+1);\nfilldraw(shift(3,0)*unitsquare, palered, black+1);\nfilldraw(shift(1,1)*unitsquare, palered, black+1);\nfilldraw(shift(1,2)*unitsquare, palered, black+1);\nfilldraw(shift(1,3)*unitsquare, palered, black+1);\nfilldraw(shift(1,4)*unitsquare, palered, black+1);\n\nfor (int i=N; i<a.length-1; ++i) {\n  filldraw(shift(a[i]-1, a[i+1]-1)*unitsquare, paleyellow, black+1);\n}\ndraw((0,0)--(4,0)--(4,1)--(2,1)--(2,5)--(1,5)--(1,1)--(0,1)--cycle, brown+2);\nlabel(\"$\\boxed{N}$\", (a[N-1]-0.5, a[N]-0.5), fontsize(14pt));\n\nvoid draw_arrow(int k, pen p) {\n  draw((a[k-1]-0.5,a[k]-0.5)--(a[k]-0.5,a[k+1]-0.5,\n    p, EndArrow(TeXHead), Margin(2,2));\n}\n\ndraw((2,0)--(2,-0.7), deepgreen);\ndraw((4,12)--(4,-0.7), deepgreen);\nlabel(\"$L$\", (2,-0.7), dir(-90), deepgreen);\nlabel(\"$M$\", (4,-0.7), dir(-90), deepgreen);\ndraw((4,4)--(11,4), deepgreen);\n\nfor (int j=1; j<=11; ++j) {\n  label(\"$\"+(string)j+\"$\", (j-0.5,0), dir(-90), blue+fontsize(10pt));\n}\n\n\n// Figure 2: claim with C\nfilldraw(shift(a[18]-1, a[19]-1)*unitsquare, yellow, black+2);\nfilldraw(shift(a[19]-1, a[20]-1)*unitsquare, yellow, black+2);\nfilldraw(shift(a[30]-1, a[31]-1)*unitsquare, yellow, black+2);\nfilldraw(shift(a[31]-1, a[32]-1)*unitsquare, yellow, black+2);\ndraw_arrow(19, blue+1.1);\ndraw_arrow(31, blue+1.1);\n\nfor (int i=N; i<a.length-1; ++i) {\n  label(\"$\"+(string)(i+1)+\"$\", (a[i]-0.5, a[i+1]-0.5), fontsize(12pt));\n}\n</div>\n</div>\n\n<div class=\"claim*?\">\n  If the $(k+1)$\\ts{st} tower grows arbitrarily high, so does tower $k$.\n  In fact, there exists a constant $C$ such that $h_{k} \\ge h_{k+1} - C$ at all times.\n</div>\n<div class=\"proof\">\n  Suppose $B_n$ is a yellow block in tower $k+1$.\n  Then with at most finitely many exceptions, $B_{n-1}$ is a yellow block at height $k+1$,\n  and the block $B_r$ right below $B_{n-1}$ is also yellow;\n  then $B_{r+1}$ is in tower $k$.\n  Hence, with at most finitely many exceptions, the map\n  \\[ B_n \\mapsto B_{n-1} \\mapsto B_r \\mapsto B_{r+1} \\]\n  provides an injective map taking each yellow block in tower $k+1$\n  to a yellow block in tower $k$.\n  (The figure above shows $B_{32} \\to B_{31} \\to B_{19} \\to B_{20}$ as an example.)\n</div>\n\n<div class=\"claim*?\">\n  If $a_n > M$ then $a_{n+1} \\le M$.\n</div>\n<div class=\"proof\">\n  Assume for contradiction there's a first moment where $a_n > M$ and $a_{n+1} > M$,\n  meaning the block $B_n$ was added to an all-yellow tower past $M$\n  that has height exceeding $M$.\n  (This is the X'ed out region in the figure above.)\n  In $B_n$'s tower, every (yellow) block (including $B_n$)\n  was contributed by a block placed in different towers at height $a_n > M$.\n  So before $B_n$, there were already $a_{n+1} > M$ towers of height more than $M$.\n  This contradicts minimality of $n$.\n</div>\n\nIt follows that the set of indices with $a_n \\le M$\nhas arithmetic density at least half, so certainly\nat least some of the numbers must occur infinitely often.\nOf the numbers in $\\{1,2,\\dots,M\\}$,\ndefine $L$ such that towers $1$ through $L$ grow unbounded\nbut towers $L+1$ through $M$ do not.\nThen we can pick a larger threshold $N' > N$ such that\n<ul>\n  \\ii Towers $1$ through $L$ have height greater than $(M,N)$;\n  \\ii Towers $L+1$ through $M$ will receive no further blocks;\n  \\ii $a_{N'} \\le L$.\n</ul>\nAfter this threshold, the following statement is true:\n<div class=\"claim*?\">\n  [Alternating small and big]\n  The terms $a_{N'}$, $a_{N' + 2}$, $a_{N' + 4}$, \\dots\\ are all at most $L$ while\n  the terms $a_{N' + 1}$, $a_{N' + 3}$, $a_{N' + 5}$, \\dots\\ are all greater than $M$.\n</div>\n\n\\paragraph{Automaton for $n \\equiv N' \\pmod 2$.}\nFrom now on we always assume $n > N'$.\nWhen $n \\equiv N' \\pmod 2$, i.e., when $a_n$ is small, we define the state\n\\[ S(n) = (h_1, h_2, \\dots, h_L; a_n). \\]\nFor example, in the figure below, we illustrate how\n\\[ S(34) = (9,11;a_{34}=1) \\longrightarrow S(36) = (9,12;a_{36}=2) \\]\n<div class=\"center\">\n<div class=\"asy\">\n    unitsize(0.85cm);\n    int[] a = {1,2,2,2,2,2,3,4,1,2,6,1,3,2,7,1,4,2,8,1,5,1,6,2,9,1,7,2,10,1,8,2,11,1,9,2,12};\n    int N = 8;\n\n    filldraw(shift(0,0)*unitsquare, palered, black+1);\n    filldraw(shift(1,0)*unitsquare, palered, black+1);\n    filldraw(shift(2,0)*unitsquare, palered, black+1);\n    filldraw(shift(3,0)*unitsquare, palered, black+1);\n    filldraw(shift(1,1)*unitsquare, palered, black+1);\n    filldraw(shift(1,2)*unitsquare, palered, black+1);\n    filldraw(shift(1,3)*unitsquare, palered, black+1);\n    filldraw(shift(1,4)*unitsquare, palered, black+1);\n\n    for (int i=N; i<a.length-1; ++i) {\n      filldraw(shift(a[i]-1, a[i+1]-1)*unitsquare, paleyellow, black+1);\n    }\n    draw((0,0)--(4,0)--(4,1)--(2,1)--(2,5)--(1,5)--(1,1)--(0,1)--cycle, brown+2);\n    label(\"$\\boxed{N}$\", (a[N-1]-0.5, a[N]-0.5), fontsize(14pt));\n\nvoid draw_arrow(int k, pen p) {\n  draw((a[k-1]-0.5,a[k]-0.5)--(a[k]-0.5,a[k+1]-0.5,\n    p, EndArrow(TeXHead), Margin(2,2));\n}\n\ndraw((2,0)--(2,-0.7), deepgreen);\ndraw((4,12)--(4,-0.7), deepgreen);\nlabel(\"$L$\", (2,-0.7), dir(-90), deepgreen);\nlabel(\"$M$\", (4,-0.7), dir(-90), deepgreen);\ndraw((4,4)--(11,4), deepgreen);\n\nfor (int j=1; j<=11; ++j) {\n  label(\"$\"+(string)j+\"$\", (j-0.5,0), dir(-90), blue+fontsize(10pt));\n}\n\n// Figure 3: automaton\nfilldraw(shift(a[33]-1, a[34]-1)*unitsquare, yellow, black+2);\nfilldraw(shift(a[34]-1, a[35]-1)*unitsquare, yellow, black+2);\nfilldraw(shift(a[35]-1, a[36]-1)*unitsquare, yellow, black+2);\ndraw_arrow(34, deepgreen+1.1);\ndraw_arrow(35, deepgreen+1.1);\n\nfor (int i=N; i<a.length-1; ++i) {\n  label(\"$\"+(string)(i+1)+\"$\", (a[i]-0.5, a[i+1]-0.5), fontsize(12pt));\n}\n</div>\n</div>\n\nThe final element $a_n$ simply reminds us which tower was most recently incremented.\nAt this point we can give a complete description of how to move from $S(n)$ to $S(n+2)$:\n<ul>\n  \\ii The intermediate block $B_{n+1}$ is placed in the tower\n  corresponding to the height $a_{n+1}$ of $B_n$;\n  \\ii That tower will have height $a_{n+2}$ equal to the number of towers\n  with height at least $a_{n+1}$; that is, it equals the cardinality of the set\n  \\[ \\{ i \\colon h_i \\ge h_{a_n} \\} \\]\n  \\ii We increment $h_{a_{n+2}}$ by $1$ and update $a_n$.\n</ul>\n\nFor example, the illustrated $S(34) \\to S(36)$\ncorresponds to the block $B_{34}$ at height $h_1$ in tower $1$\ngiving the block $B_{35}$ at height $2$ in tower $h_1$,\nthen block $B_{36}$ at height $h_2 + 1$ being placed in tower $2$.\n\n\n\\paragraph{Pigeonhole periodicity argument.}\nBecause only the <em>relative</em> heights matter in the automata above,\nif we instead define\n\\[ T(n) = (h_1-h_2, h_2-h_3, \\dots, h_{L-1}-h_L; a_n). \\]\nthen $T(n+2)$ can be determined from just $T(n)$.\n\nSo it would be sufficient to show $T(n)$ only takes on finitely many values\nto show that $T(n)$ (and hence $a_n$) is eventually periodic.\n\nSince we have the bound $h_{k+1} \\le h_k + C$,\nwe are done upon proving the following lower bound:\n<div class=\"claim*?\">\n  For every $1 \\le \\ell < L$ and $n > N'$,\n  we have $h_\\ell \\le h_{\\ell+1} + C \\cdot (L-1)$.\n</div>\n<div class=\"proof\">\n  Assume for contradiction that there is some moment $n > N'$ such that\n  \\[ h_\\ell > h_{\\ell+1} + C \\cdot (L-1) \\]\n  and WLOG assume that $h_\\ell$ was just updated at the moment $n$.\n  Together with $h_{k+1} \\le h_k + C$ for all $k$ and triangle inequality, we conclude\n  \\[ \\min(h_1, \\dots, h_\\ell) > q := \\max(h_{\\ell+1}, \\dots, h_L). \\]\n  We find that the blocks now in fact alternate between being placed\n  among the first $\\ell$ towers and in towers with indices greater than $q$ thereafter.\n  Hence the heights $h_{\\ell+1}$, \\dots, $h_L$ never grow after this moment.\n  This contradicts the definition of $L$.\n</div>\n\n<div class=\"remark*?\">\n  In fact, it can be shown that the period is actually exactly $L$,\n  meaning the periodic part will be exactly a permutation of $(1,2,\\dots,L)$.\n  For any $L$, it turns out there is indeed a permutation achieving that periodic part.\n</div>\n\\pagebreak\n\n\\section{Solutions to Day 2}", "category": null, "source": "IMO", "year": 2024, "content": "Let $a_1$, $a_2$, $a_3$, \\dots be an infinite sequence of positive integers, and let $N$ be a positive integer. Suppose that, for each $n > N$, the number $a_n$ is equal to the number of times $a_{n-1}$ appears in the list $(a_1, a_2, \\dots, a_{n-1})$. Prove that at least one of the sequences $a_1$, $a_3$, $a_5$, \\dots and $a_2$, $a_4$, $a_6$, \\dots is eventually periodic."}
{"id": "imo-2024-q4", "question": "Let triangle $ABC$ with incenter $I$ satisfying $AB < AC < BC$.\nLet $X$ be a point on line $BC$, different from $C$,\nsuch that the line through $X$ and parallel to $AC$ is tangent to the incircle.\nSimilarly, let $Y$ be a point on line $BC$, different from $B$,\nsuch that the line through $Y$ and parallel to $AB$ is tangent to the incircle.\nLine $AI$ intersects the circumcircle of triangle $ABC$ again at $P$.\nLet $K$ and $L$ be the midpoints of $AC$ and $AB$, respectively.\nProve that $\\angle KIL + \\angle YPX = 180^{\\circ}$.", "solution": "<div class=\"mdframed\">\nLet triangle $ABC$ with incenter $I$ satisfying $AB < AC < BC$. Let $X$ be a point on line $BC$, different from $C$, such that the line through $X$ and parallel to $AC$ is tangent to the incircle. Similarly, let $Y$ be a point on line $BC$, different from $B$, such that the line through $Y$ and parallel to $AB$ is tangent to the incircle. Line $AI$ intersects the circumcircle of triangle $ABC$ again at $P$. Prove that $\\angle KIL + \\angle YPX = 180^{\\circ}$.\n\\end{div}\nLet $T$ be the reflection of $A$ over $I$. \n\n<div class=\"claim*\">\n  We have $\\angle KIL = \\angle BTC$, and lines $TX$ and $TY$ are tangent to the incircle.\n</div>\n<div class=\"proof\">\n  The first part is true since $\\triangle BTC$ is the image of $\\triangle KIL$ under a homothety of ratio $2$. The second part is true because lines $AB$, $AC$, $TX$, $TY$ determine a rhombus with center $I$.\n</div>\n\nWe thus delete $K$ and $L$ from the picture altogether; they aren't needed anymore.\n\n<div class=\"center\">\n<div class=\"asy\">\nsize(11cm);\npair A = dir(105);\npair B = dir(200);\npair C = dir(340);\npair P = dir(270);\nfilldraw(unitcircle, opacity(0.1)+lightcyan, blue);\npair I = incenter(A, B, C);\nfilldraw(incircle(A, B, C), opacity(0.1)+lightcyan, blue);\ndraw(A--B--C--cycle, blue);\npair E = foot(I, C, A);\npair F = foot(I, A, B);\npair T = 2*I-A;\npair U = 2*I-E;\npair V = 2*I-F;\ndraw(U--T--V, deepgreen);\ndraw(B--T--C, red);\npair X = extension(U, T, B, C);\npair Y = extension(V, T, B, C);\ndraw(A--P, gray);\ndraw(circumcircle(B, X, P), gray+dashed);\ndraw(circumcircle(C, Y, P), gray+dashed);\n\ndot(\"$A$\", A, dir(A));\ndot(\"$B$\", B, dir(160));\ndot(\"$C$\", C, dir(20));\ndot(\"$P$\", P, dir(45));\ndot(\"$I$\", I, dir(250));\ndot(\"$T$\", T, dir(225));\ndot(\"$X$\", X, dir(X));\ndot(\"$Y$\", Y, dir(310));\n</div>\n</div>\n\n<div class=\"claim*\">\n  We have $BXPT$ and $CYPT$ are cyclic.\n</div>\n<div class=\"proof\">\n  $\\angle TYC = \\angle TYB = \\angle ABC = \\angle APC = \\angle TPC$ and similarly.\n  (Some people call this Reim's theorem.)\n</div>\n\nTo finish, observe that\n\\[\n\\angle CTB = \\angle CTP + \\angle PTB = \\angle CYP + \\angle PXB = \\angle XYP + \\angle XYP = \\angle XPY\n\\]\nas desired.\n\\pagebreak", "category": null, "source": "IMO", "year": 2024, "content": "Let triangle $ABC$ with incenter $I$ satisfying $AB < AC < BC$.  \nLet $X$ be a point on line $BC$, different from $C$, such that the line through $X$ and parallel to $AC$ is tangent to the incircle.  \nSimilarly, let $Y$ be a point on line $BC$, different from $B$, such that the line through $Y$ and parallel to $AB$ is tangent to the incircle.  \nLine $AI$ intersects the circumcircle of triangle $ABC$ again at $P$.  \nLet $K$ and $L$ be the midpoints of $AC$ and $AB$, respectively.  \nProve that $\\angle KIL + \\angle YPX = 180^{\\circ}$."}
{"id": "imo-2024-q5", "question": "Turbo the snail is in the top row of a grid with $2024$ rows and $2023$ columns\nand wants to get to the bottom row.\nHowever, there are $2022$ hidden monsters, one in every row except the first and last,\nwith no two monsters in the same column.\n\nTurbo makes a series of attempts to go from the first row to the last row.\nOn each attempt, he chooses to start on any cell in the first row,\nthen repeatedly moves to an orthogonal neighbor.\n(He is allowed to return to a previously visited cell.)\nIf Turbo reaches a cell with a monster,\nhis attempt ends and he is transported back to the first row to start a new attempt.\nThe monsters do not move between attempts, and Turbo remembers whether or not each cell\nhe has visited contains a monster.\nIf he reaches any cell in the last row, his attempt ends and Turbo wins.\n\nFind the smallest integer $n$ such that Turbo has a strategy which guarantees\nbeing able to reach the bottom row in at most $n$ attempts,\nregardless of how the monsters are placed.", "solution": "<div class=\"mdframed\">\nTurbo the snail is in the top row of a grid with $2024$ rows and $2023$ columns\nand wants to get to the bottom row.\nHowever, there are $2022$ hidden monsters, one in every row except the first and last,\nwith no two monsters in the same column.\n\nTurbo makes a series of attempts to go from the first row to the last row.\nOn each attempt, he chooses to start on any cell in the first row,\nthen repeatedly moves to an orthogonal neighbor.\n(He is allowed to return to a previously visited cell.)\nIf Turbo reaches a cell with a monster,\nhis attempt ends and he is transported back to the first row to start a new attempt.\nThe monsters do not move between attempts, and Turbo remembers whether or not each cell\nhe has visited contains a monster.\nIf he reaches any cell in the last row, his attempt ends and Turbo wins.\n\nFind the smallest integer $n$ such that Turbo has a strategy which guarantees\nbeing able to reach the bottom row in at most $n$ attempts,\nregardless of how the monsters are placed.\n</div>\nSurprisingly the answer is $n = 3$ for <em>any</em> grid size $s \\times (s-1)$ when $s \\ge 4$.\nWe prove this in that generality.\n\n\\paragraph{Proof that at least three attempts are needed.}\nWhen Turbo first moves into the second row, Turbo could encounter a monster $M_1$ right away.\nThen on the next attempt, Turbo must enter the third row in different column as $M_1$,\nand again could encounter a monster $M_2$ right after doing so.\nThis means no strategy can guarantee fewer than three attempts.\n\n\\paragraph{Strategy with three attempts.}\nOn the first attempt, we have Turbo walk through the entire second row\nuntil he finds the monster $M_1$ in it.\nThen we get two possible cases.\n\n\\subparagraph{Case where $M_1$ is not on the edge.}\nIn the first case, if that monster $M_1$ is not on the edge of the row,\nthen Turbo can trace two paths below it as shown below.\nAt least one of these paths works, hence three attempts is sufficient.\n\n<div class=\"center\">\n<div class=\"asy\">\nusepackage(\"amssymb\");\nunitsize(0.7cm);\npen gr = gray+linetype(\"4 2\");\nint n = 6;\nfor (int i=0; i<=n-1; ++i) {\n  draw((0,i)--(n,i), gr);\n}\nfor (int i=0; i<=n; ++i) {\n  draw((i,0)--(i,n-1), gr);\n}\ndraw(box((0,-1), (n,0)), black);\ndraw(box((0,n-1), (n,n)), black);\ndraw(box((0,-1), (n,n)), black);\nlabel((n/2,n-0.5), \"Starting row\");\nlabel((n/2,-0.5), \"Goal row\");\n\nlabel((2.5,4.5), \"$M_1$\", red);\ndotfactor *= 2;\ndot((1.5,4.5), deepgreen);\ndot((3.5,4.5), deepgreen);\ndraw((1.5,4.5)--(1.5,3.5)--(2.3,3.5)--(2.3,0.2), deepgreen+1.2, EndArrow(TeXHead));\ndraw((3.5,4.5)--(3.5,3.5)--(2.7,3.5)--(2.7,0.2), deepgreen+1.2, EndArrow(TeXHead));\n</div>\n</div>\n\n\\subparagraph{Case where $M_1$ is on the edge.}\nWLOG, $M_1$ is in the leftmost cell.\nThen Turbo follows the green staircase pattern shown in the left figure below.\nIf the staircase is free of monsters, then Turbo wins on the second attempt.\nOtherwise, if a monster $M_2$ is encountered on the staircase,\nTurbo has found a safe path to the left of $M_2$;\nthen Turbo can use this to reach the column $M_1$ is in, and escape from there.\nThis is shown in purple in the center and right figure\n(there are two slightly different cases depending on whether $M_2$\nwas encountered going east or south).\n<div class=\"center\">\n<div class=\"asy\">\nusepackage(\"amssymb\");\nunitsize(0.65cm);\npen gr = gray+linetype(\"4 2\");\nint n = 6;\ndotfactor *= 2;\n\npicture pic1, pic2, pic3;\npicture[] pics = {pic1, pic2, pic3};\n\nfor (int j=0; j<3; ++j) {\n  for (int i=0; i<=n-1; ++i) {\n    draw(pics[j], (0,i)--(n,i), gr);\n  }\n  for (int i=0; i<=n; ++i) {\n    draw(pics[j], (i,0)--(i,n-1), gr);\n  }\n  draw(pics[j], box((0,-1), (n,0)), black);\n  draw(pics[j], box((0,n-1), (n,n)), black);\n  draw(pics[j], box((0,-1), (n,n)), black);\n  label(pics[j], \"Starting row\", (n/2,n-0.5));\n  label(pics[j], \"Goal row\", (n/2,-0.5));\n}\n\nlabel(pic1, \"$M_1$\", (0.5,4.5), red);\ndot(pic1, (1.5,4.5), deepgreen);\ndraw(pic1, (1.5,4.5)--(2.5,4.5)--(2.5,3.5)--(3.5,3.5)--(3.5,2.5)\n  --(4.5,2.5)--(4.5,1.5)--(5.5,1.5)--(5.5,0.2), deepgreen+1.2, EndArrow(TeXHead));\n\nlabel(pic2, \"$M_1$\", (0.5,4.5), red);\nlabel(pic2, \"$M_2$\", (4.5,2.5), red);\ndot(pic2, (1.5,4.5), deepgreen);\ndraw(pic2, (3.5,2.5)--(4.5,2.5)--(4.5,1.5)--(5.5,1.5)--(5.5,0.2), deepgreen+dashed);\ndraw(pic2, (1.5,4.5)--(2.5,4.5)--(2.5,3.5)--(3.5,3.5)--(3.5,2.5)--(0.5,2.5)--(0.5,0.2),\n  purple+1.5, EndArrow(TeXHead));\n\nlabel(pic3, \"$M_1$\", (0.5,4.5), red);\nlabel(pic3, \"$M_2$\", (4.5,1.5), red);\ndot(pic3, (1.5,4.5), deepgreen);\ndraw(pic3, (3.5,2.5)--(4.5,2.5)--(4.5,1.5)--(5.5,1.5)--(5.5,0.2), deepgreen+dashed);\ndraw(pic3, (1.5,4.5)--(2.5,4.5)--(2.5,3.5)--(3.5,3.5)--(3.5,1.5)--(0.5,1.5)--(0.5,0.2),\n  purple+1.5, EndArrow(TeXHead));\n\nadd(pic1);\nadd(shift(7,0)*pic2);\nadd(shift(14,0)*pic3);\n</div>\n</div>\nThus the problem is solved in three attempts, as promised.\n\n\\paragraph{Extended remark: all working strategies look similar to this.}\nAs far as we know, all working strategies are variations of the above.\nIn fact, we will try to give a description of the space of possible strategies,\nalthough this needs a bit of notation.\n\n\\begin{definition*}\nFor simplicity, we only use $s$ even in the figures below.\nWe define the <em>happy triangle</em> as the following cells:\n<ul>\n<li>All $s-1$ cells in the first row (which has no monsters).</li>\n<li>The center $s-3$ cells in the second row.</li>\n<li>The center $s-5$ cells in the third row.</li>\n<li>\\dots</li>\n<li>The center cell in the $\\frac s2$\\textsuperscript{th} row.</li>\n</ul>\n\\end{definition*}\nFor $s=12$, the happy triangle is the region shaded in the thick border below.\n<div class=\"center\">\n<div class=\"asy\">\nusepackage(\"amssymb\");\nunitsize(0.7cm);\npen gr = gray+linetype(\"4 2\");\nvoid setup(int n) {\n  for (int i=0; i<=n-1; ++i) {\n    draw((0,i)--(n,i), gr);\n  }\n  for (int i=0; i<=n; ++i) {\n    draw((i,0)--(i,n-1), gr);\n  }\n  draw(box((0,-1), (n,0)), black);\n  draw(box((0,n-1), (n,n)), black);\n  draw(box((0,-1), (n,n)), black);\n  label((n/2,n-0.5), \"Starting row\");\n  label((n/2,-0.5), \"Goal row\");\n\n  path p = (0,n);\n  for (int i=0; i<n/2; ++i) {\n    p = p--(i,n-1-i)--(i+1,n-1-i);\n  }\n  for (int i=(n+1)#2; i<n; ++i) {\n    p = p--(i,i)--(i+1,i);\n  }\n  p = p--(n,n)--cycle;\n  filldraw(p, opacity(0.15)+yellow, blue+1.8);\n}\nsetup(11);\n</div>\n</div>\n\\begin{definition*}\n  Given a cell, define a <em>shoulder</em> to be the cell directly northwest or northeast of it.\n  Hence there are two shoulders of cells outside the first and last column,\n  and one shoulder otherwise.\n\\end{definition*}\n\nThen solutions roughly must distinguish between these two cases:\n<ul>\n<li><strong>Inside happy triangle:</strong>\n    If the first monster $\\color{red}M_1$ is found in the <em>happy triangle</em>,\n    and there is a safe path found by Turbo to the two shoulders\n    (marked $\\color{green!60!black}\\bigstar$ in the figure),\n    then one can finish in two more moves by considering the two paths from $\\color{green!60!black}\\bigstar$\n    that cut under the monster $\\color{red}M_1$; one of them must work.\n    This slightly generalizes the easier case in the solution above\n    (which focuses only on the case where $\\color{red}M_1$ is in the first row).\n<div class=\"center\">\n<div class=\"asy\">\n        usepackage(\"amssymb\");\n        unitsize(0.7cm);\n        pen gr = gray+linetype(\"4 2\");\n        void setup(int n) {\n          for (int i=0; i<=n-1; ++i) {\n            draw((0,i)--(n,i), gr);\n          }\n          for (int i=0; i<=n; ++i) {\n            draw((i,0)--(i,n-1), gr);\n          }\n          draw(box((0,-1), (n,0)), black);\n          draw(box((0,n-1), (n,n)), black);\n          draw(box((0,-1), (n,n)), black);\n          label((n/2,n-0.5), \"Starting row\");\n          label((n/2,-0.5), \"Goal row\");\n\n          path p = (0,n);\n          for (int i=0; i<n/2; ++i) {\n            p = p--(i,n-1-i)--(i+1,n-1-i);\n          }\n          for (int i=(n+1)#2; i<n; ++i) {\n            p = p--(i,i)--(i+1,i);\n          }\n          p = p--(n,n)--cycle;\n          filldraw(p, opacity(0.15)+yellow, blue+1.8);\n        }\n        setup(7);\n        label((2.5,4.5), \"$M_1$\", red);\n        label((1.5,5.5), \"$\\bigstar$\", deepgreen);\n        label((3.5,5.5), \"$\\bigstar$\", deepgreen);\n        draw((1.5,5.5)--(1.5,3.5)--(2.3,3.5)--(2.3,0.2), deepgreen+1.2, EndArrow(TeXHead));\n        draw((3.5,5.5)--(3.5,3.5)--(2.7,3.5)--(2.7,0.2), deepgreen+1.2, EndArrow(TeXHead));\n</div>\n</div>\n\n<li><strong>Outside happy triangle:</strong>\n    Now suppose the first monster $\\color{red}M_1$ is outside the <em>happy triangle</em>.\n    Of the two shoulders, take the one closer to the center\n    (if in the center column, either one works; if only one shoulder, use it).\n    If there is a safe path to that shoulder,\n    then one can take a staircase pattern towards the center, as shown in the figure.\n    In that case, the choice of shoulder and position guarantees the staircase\n    reaches the bottom row, so that if no monster is along this path, the algorithm ends.\n    Otherwise, if one encounters a second monster along the staircase,\n    then one can use the third trial to cut under the monster $\\color{red}M_1$.\n<div class=\"center\">\n<div class=\"asy\">\n        usepackage(\"amssymb\");\n        unitsize(0.7cm);\n        pen gr = gray+linetype(\"4 2\");\n        void setup(int n) {\n          for (int i=0; i<=n-1; ++i) {\n            draw((0,i)--(n,i), gr);\n          }\n          for (int i=0; i<=n; ++i) {\n            draw((i,0)--(i,n-1), gr);\n          }\n          draw(box((0,-1), (n,0)), black);\n          draw(box((0,n-1), (n,n)), black);\n          draw(box((0,-1), (n,n)), black);\n          label((n/2,n-0.5), \"Starting row\");\n          label((n/2,-0.5), \"Goal row\");\n\n          path p = (0,n);\n          for (int i=0; i<n/2; ++i) {\n            p = p--(i,n-1-i)--(i+1,n-1-i);\n          }\n          for (int i=(n+1)#2; i<n; ++i) {\n            p = p--(i,i)--(i+1,i);\n          }\n          p = p--(n,n)--cycle;\n          filldraw(p, opacity(0.15)+yellow, blue+1.8);\n        }\n\n        setup(9);\n        label((1.5,3.5), \"$M_1$\", red);\n        label((2.5,4.5), \"$\\bigstar$\", deepgreen);\n        draw((2.5,4.5)--(2.5,3.5)--(3.5,3.5)--(3.5,2.5)--(4.5,2.5)--(4.5,1.5)--(5.5,1.5)--(5.5,0.2),\n          deepgreen+1.2, EndArrow(TeXHead));\n</div>\n      \\qquad\n<div class=\"asy\">\n        usepackage(\"amssymb\");\n        unitsize(0.7cm);\n        pen gr = gray+linetype(\"4 2\");\n        void setup(int n) {\n          for (int i=0; i<=n-1; ++i) {\n            draw((0,i)--(n,i), gr);\n          }\n          for (int i=0; i<=n; ++i) {\n            draw((i,0)--(i,n-1), gr);\n          }\n          draw(box((0,-1), (n,0)), black);\n          draw(box((0,n-1), (n,n)), black);\n          draw(box((0,-1), (n,n)), black);\n          label((n/2,n-0.5), \"Starting row\");\n          label((n/2,-0.5), \"Goal row\");\n\n          path p = (0,n);\n          for (int i=0; i<n/2; ++i) {\n            p = p--(i,n-1-i)--(i+1,n-1-i);\n          }\n          for (int i=(n+1)#2; i<n; ++i) {\n            p = p--(i,i)--(i+1,i);\n          }\n          p = p--(n,n)--cycle;\n          filldraw(p, opacity(0.15)+yellow, blue+1.8);\n        }\n\n        setup(9);\n        label((1.5,3.5), \"$M_1$\", red);\n        label((2.5,4.5), \"$\\bigstar$\", deepgreen);\n        draw((2.5,4.5)--(2.5,3.5)--(3.5,3.5)--(3.5,2.5)--(4.5,2.5)--(4.5,1.5)--(5.5,1.5)--(5.5,0.2),\n          deepgreen+dashed, EndArrow(TeXHead));\n        label((5.5,1.5), \"$M_2$\", red);\n        draw((2.5,4.5)--(2.5,3.5)--(3.5,3.5)--(3.5,2.5)--(4.5,2.5)--(4.5,1.5)--(1.5,1.5)--(1.5,0.2),\n          purple+1.5, EndArrow(TeXHead));\n</div>\n</div>\n</ul>\n\nWe now prove the following proposition:\nin any valid strategy for Turbo,\nin the case where Turbo first encounters a monster upon leaving the happy triangle,\nthe second path <em>must</em> outline the same staircase shape.\n\nThe monsters pre-commit to choosing their pattern to be\n<em>either</em> a NW-SE diagonal or NE-SW diagonal, with a single one-column gap;\nsee figure below for an example.\nNote that this forces any valid path for Turbo to pass through the particular gap.\n\n<div class=\"center\">\n<div class=\"asy\">\n    usepackage(\"amssymb\");\n    unitsize(0.7cm);\n    pen gr = gray+linetype(\"4 2\");\n    void setup(int n) {\n      for (int i=0; i<=n-1; ++i) {\n        draw((0,i)--(n,i), gr);\n      }\n      for (int i=0; i<=n; ++i) {\n        draw((i,0)--(i,n-1), gr);\n      }\n      draw(box((0,-1), (n,0)), black);\n      draw(box((0,n-1), (n,n)), black);\n      draw(box((0,-1), (n,n)), black);\n      label((n/2,n-0.5), \"Starting row\");\n      label((n/2,-0.5), \"Goal row\");\n\n      path p = (0,n);\n      for (int i=0; i<n/2; ++i) {\n        p = p--(i,n-1-i)--(i+1,n-1-i);\n      }\n      for (int i=(n+1)#2; i<n; ++i) {\n        p = p--(i,i)--(i+1,i);\n      }\n      p = p--(n,n)--cycle;\n      filldraw(p, opacity(0.15)+yellow, blue+1.8);\n    }\n    setup(11);\n\n    for (int i=0; i<7; ++i) {\n      label((i+0.5,9.5-i), \"$M$\", red);\n    }\n    for (int i=7; i<10; ++i) {\n      label((i+1.5,9.5-i), \"$M$\", red);\n    }\n</div>\n</div>\n\nWe may assume without loss of generality that Turbo first encounters a monster $M_1$\nwhen Turbo first leaves the happy triangle, and that this forces an NW-SE configuration.\n\n<div class=\"center\">\n<div class=\"asy\">\n    usepackage(\"amssymb\");\n    unitsize(0.7cm);\n    pen gr = gray+linetype(\"4 2\");\n    void setup(int n) {\n      for (int i=0; i<=n-1; ++i) {\n        draw((0,i)--(n,i), gr);\n      }\n      for (int i=0; i<=n; ++i) {\n        draw((i,0)--(i,n-1), gr);\n      }\n      draw(box((0,-1), (n,0)), black);\n      draw(box((0,n-1), (n,n)), black);\n      draw(box((0,-1), (n,n)), black);\n      label((n/2,n-0.5), \"Starting row\");\n      label((n/2,-0.5), \"Goal row\");\n\n      path p = (0,n);\n      for (int i=0; i<n/2; ++i) {\n        p = p--(i,n-1-i)--(i+1,n-1-i);\n      }\n      for (int i=(n+1)#2; i<n; ++i) {\n        p = p--(i,i)--(i+1,i);\n      }\n      p = p--(n,n)--cycle;\n      filldraw(p, opacity(0.15)+yellow, blue+1.8);\n    }\n    setup(13);\n    label((0.5,11.5), \"($M$)\", red+fontsize(9pt));\n    label((1.5,10.5), \"($M$)\", red+fontsize(9pt));\n    label((2.5,9.5), \"($M$)\", red+fontsize(9pt));\n    label((3.5,8.5), \"$M_1$\", red);\n    label((4.5,7.5), \"X\", brown);\n    label((11.5,1.5), \"$M_2$\", red);\n    for (int i=1; i<=6; ++i) {\n      label((11.5-i,1.5+i), \"$\\clubsuit$\", deepgreen);\n    }\n</div>\n</div>\n\nThen the following is true:\n\\begin{proposition*}\n  The strategy of Turbo on the second path <em>must</em>\n  visit every cell in ``slightly raised diagonal'' marked with\n  $\\color{green!60!black}\\clubsuit$ in the figure above\n  in order from top to bottom, until it encounters a second Monster $M_2$\n  (or reaches the bottom row and wins anyway).\n  It's both okay and irrelevant if Turbo visits other cells above this diagonal,\n  but the marked cells must be visited from top to bottom in that order.\n\\end{proposition*}\n<div class=\"proof\">\n  If Turbo tries to sidestep by visiting the cell southeast of $M_1$\n  (marked {\\color{brown}X} in the Figure),\n  then Turbo clearly cannot finish after this (for $s$ large enough).\n  Meanwhile, suppose Turbo tries to ``skip'' one of the $\\color{green!60!black}\\clubsuit$,\n  say in column $C$, then the gap could equally well be in the column to the left of $C$.\n  This proves the proposition.\n</div>\n\n<div class=\"remark*\">\n  [Memories of safe cells are important, not just monster cells]\n  Here is one additional observation that one can deduce from this.\n  We say a set $\\mathcal S$ of revealed monsters is called <em>obviously winnable</em> if,\n  based on only the positions of the monsters\n  (and not the moves or algorithm that were used to obtain them),\n  one can identify a guaranteed winning path for Turbo using only $\\mathcal S$.\n  For example, two monsters in adjacent columns which are not diagonally\n  adjacent is obviously winnable.\n\n  Then no strategy can guarantee obtaining an obviously winnable set in $2$ moves\n  (or even $k$ moves for any constant $k$, if $s$ is large enough in terms of $k$).\n  So any valid strategy must <em>also</em> use the <em>memory</em> of identified safe cells\n  that do not follow just from the revealed monster positions.\n</div>\n\\pagebreak", "category": null, "source": "IMO", "year": 2024, "content": "Turbo the snail is in the top row of a grid with $2024$ rows and $2023$ columns\nand wants to get to the bottom row.\nHowever, there are $2022$ hidden monsters, one in every row except the first and last,\nwith no two monsters in the same column.\n\nTurbo makes a series of attempts to go from the first row to the last row.\nOn each attempt, he chooses to start on any cell in the first row,\nthen repeatedly moves to an orthogonal neighbor.\n(He is allowed to return to a previously visited cell.)\nIf Turbo reaches a cell with a monster,\nhis attempt ends and he is transported back to the first row to start a new attempt.\nThe monsters do not move between attempts, and Turbo remembers whether or not each cell\nhe has visited contains a monster.\nIf he reaches any cell in the last row, his attempt ends and Turbo wins.\n\nFind the smallest integer $n$ such that Turbo has a strategy which guarantees\nbeing able to reach the bottom row in at most $n$ attempts,\nregardless of how the monsters are placed."}
{"id": "imo-2024-q6", "question": "A function $f \\colon \\QQ \\to \\QQ$ is called \\emph{aquaesulian}\nif the following property holds: for every $x,y \\in \\mathbb{Q}$,\n\\[ f(x+f(y)) = f(x) + y \\quad \\text{or} \\quad f(f(x)+y) = x + f(y). \\]\nShow that there exists an integer $c$ such that for any aquaesulian function $f$\nthere are at most $c$ different rational numbers of the\nform $f(r) + f(-r)$ for some rational number $r$,\nand find the smallest possible value of $c$.", "solution": "```tex\n<div class=\"mdframed\">\nA function $f \\colon \\mathbb{Q} \\to \\mathbb{Q}$ is called <em>aquaesulian</em>\nif the following property holds: for every $x,y \\in \\mathbb{Q}$,\n\\[ f(x+f(y)) = f(x) + y \\quad \\text{or} \\quad f(f(x)+y) = x + f(y). \\]\nShow that there exists an integer $c$ such that for any aquaesulian function $f$\nthere are at most $c$ different rational numbers of the\nform $f(r) + f(-r)$ for some rational number $r$,\nand find the smallest possible value of $c$.\n\\end{div}\n\nWe will prove that\n\\[ \\left\\{ f(x) + f(-x) \\mid x \\in \\mathbb{Q} \\right\\} \\]\ncontains at most $2$ elements\nand give an example where there are indeed $2$ elements.\n\nWe fix the notation $x \\to y$ to mean that $f(x+f(y)) = f(x)+y$.\nSo the problem statement means that either $x \\to y$ or $y \\to x$ for all $x$, $y$.\nIn particular, we always have $x \\to x$, and hence\n\\[ f(x+f(x)) = x+f(x) \\]\nfor every $x$.\n\n\\paragraph{Construction.}\nThe function\n\\[ f(x) = \\left\\lfloor 2x \\right\\rfloor - x \\]\ncan be seen to satisfy the problem conditions.\nMoreover, $f(0)+f(0) = 0$ but $f(1/3)+f(-1/3) = -1$.\n\n<div class=\"remark*?\">\nHere is how I (Evan) found the construction.\nLet $h(x) := x+f(x)$, and let $S := h(\\mathbb{Q}) = \\{h(x) \\mid x \\in \\mathbb{Q}\\}$.\nHence $f$ is the identity on all of $S$.\nIf we rewrite the problem condition in terms of $h$ instead of $f$,\nit asserts that at least one of the equations\n\\begin{align*}\n    h(x+h(y)-y) &= h(x)+h(y) \\\\\n    h(y+h(x)-x) &= h(x)+h(y)\n\\end{align*}\nis true.\nIn particular, $S$ is closed under addition.\n\nNow, the two trivial solutions for $h$ are $h(x) = 2x$ and $h(x) = 0$.\nTo get a nontrivial construction, we must also have $S \\neq \\{0\\}$ and $S \\neq \\mathbb{Q}$.\nSo a natural guess is to take $S = \\mathbb{Z}$.\nAnd indeed $h(x) = \\left\\lfloor 2x \\right\\rfloor$ works fine.\n</div>\n\n<div class=\"remark*?\">\nThis construction is far from unique. For example,\n$f(x) = 2\\left\\lfloor x \\right\\rfloor - x = \\left\\lfloor x \\right\\rfloor - \\{x\\}$\nseems to have been more popular to find.\n</div>\n\n\\paragraph{Proof (communicated by Abel George Mathew).}\nWe start by proving:\n<div class=\"claim*?\">\n$f$ is injective.\n</div>\n<div class=\"proof\">\nSuppose $f(a) = f(b)$. WLOG $a \\to b$. Then\n\\[ f(a)+a = f(a+f(a)) = f(a+f(b)) = f(a)+b \\implies a=b. \\\\qedhere. \\]\n</div>\n\n<div class=\"claim*?\">\nSuppose $s \\to r$.\nThen either $f(r) + f(-r) = 0$ or $f(f(s)) = s+f(r)+f(-r)$.\n</div>\n<div class=\"proof\">\nTake the given statement with $x = s+f(r)$ and $y = -r$; then\n\\begin{align*}\nx + f(y) &= s + f(r) + f(-r) \\\\\ny + f(x) &= f(s+f(r)) - r = f(s).\n\\end{align*}\nBecause $f$ is injective, if $x \\to y$ then $f(r) + f(-r) = 0$.\nMeanwhile, if $y \\to x$ then indeed $f(f(s)) = s + f(r) + f(-r)$.\n</div>\n\nFinally, suppose $a$ and $b$ are different numbers for which\n$f(a)+f(-a)$ and $f(b)+f(-b)$ are both nonzero.\nAgain, WLOG $a \\to b$.\nThen\n\\[ f(a) + f(-a) \\overset{a \\to a}{=} f(f(a))-a \\overset{a \\to b}{=} f(b) + f(-b). \\]\nThis shows at most two values can occur.\n\n<div class=\"remark*?\">\nThe above solution works equally well for $f \\colon \\mathbb{R} \\to \\mathbb{R}$.\nBut the choice of $\\mathbb{Q}$ permits some additional alternate solutions.\n</div>\n\n<div class=\"remark*?\">\nAfter showing $f$ injective,\na common lemma proved is that $-f(-f(x)) = x$, i.e.\\ $f$ is an involution.\nThis provides some alternative paths for solutions.\n</div>\n```", "category": null, "source": "IMO", "year": 2024, "content": "A function $f \\colon \\mathbb{Q} \\to \\mathbb{Q}$ is called <em>aquaesulian</em> if the following property holds: for every $x,y \\in \\mathbb{Q}$,\n\n\\[\nf(x+f(y)) = f(x) + y \\quad \\text{or} \\quad f(f(x)+y) = x + f(y).\n\\]\n\nShow that there exists an integer $c$ such that for any aquaesulian function $f$ there are at most $c$ different rational numbers of the form $f(r) + f(-r)$ for some rational number $r$, and find the smallest possible value of $c$."}
